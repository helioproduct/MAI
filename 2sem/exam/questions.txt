

# 1 Билет


1.1 Ссылочный тип.
В языках со строгой дисциплиной описаний (Pascal) динамический объект 
не может иметь собственного имени, так как все идентификаторы программы 
должны быть описаны, поэтому принято не именовать, а обозначать 
динамический объект посредством ссылки на него. Переменная-ссылка должна быть
описана в разделе объявлений программы как переменная ссылочного типа. Сама
ссылка является статический объектом. Занимает одно машинное слово, по сравенению
с растущим размером динамического объекта.

Ссылочный тип - такой же простой скалярный тип, как целый, имеет аппаратную поддержку.
М-во значений переменной-ссылки - м-во объектов указанного типа. Разные типы порождают
разные ссылочные типы, м-ва значений которых не пересекаются. Пустое ссылочное значение
nil принадлежит любому м-ву значений ссылок разных типов.

Для переменных одного ссылочного типа определены операции присваивания, сравнения,
разыменовывания. Операция разыменовывания обеспечивает доступ к объекту, на который
указывает ссылка.

Динамические объекты порождаются встроенными функциями. В Си: malloc. Выделяет 
память из "кучи". В Pascal определена операция dispose, в Си: free(). Высвобождают
память, выделенную для динамического объекта, посредством передачи его ссылки в функцию.

1.2 Алгоритм КМП (Кнута-Морриса-Пратта)

...


# 2 Билет.


2.1 Деревья выражений

В синтаксическом анализе определяют формальные правила грамматики, которые определяют
правила подстановки. Так, выражение можно определеть как м-во термов, соединенных знаками
+ или -. Терм - совокупность множителей, разделенных знаками * или /. Множитель - идентификатор
или константа. Иерархическая структура выражения может быть представлена в виде древовидной структуры.

Обходя дерево-выражений мы получаем различные способы размещения очереди вершин:
инфиксную (без скобок), префиксную и постфиксную.

2.2 Таблицы с прямым доступом. (Хеш-таблицы)

Поместим нашу таблицу в обычный массив и построим преобразование ключей в адреса памяти. 
При поиске по таблице необходимо проверять точное совпадение ключей. Метод прямой 
адресации таблицы на основании функции ключа получил название хеширование.

Требование к хеш-функции:
1) преобразование ключей должно распределять их по всему диапазону значений
2) функция должна быть эффективно-вычислима при помощи нескольких простых операций
   (Часто используются битовые операции при опр. хеш функции)

Если оказалось, что в хеш-таблице обнаружилось, что строка, соотв. ключу не содержит
искомого значения, то необходима вторая попытка переадресовать этот ключ внутри таблицы.
(Рехеширование)

Рехеширование:
1) Организовать список строк с идентичным первым ключом. Элементы этого списка
   размещаются либо в основной области таблцы, либо вне ее  области переполения. 
2) Искать желаемый элемент в окрестности этого ключа.


# 3 Билет.


3.1 Вектор. Функциональная спецификация, логическое описание, физическое представление.

Вектор.

статические массивы удобны размещением в памяти и обращениями к ним, однако не всегда
известен необходимый размер массива. В этой ситуации используются динамические массивы
или векторы. Эти массивы располагаются в кучче, их размер может быть задан произвольно.

Недостаток - большое среднее время доступа к элементу, связан с Иерархической структорой
памяти ЭВМ.

Функциональная спецификация.

Вектор является последовательностью переменной длины. Время доступа - постоянно, не зависит от 
длины. Кол-во элементов может быть изменено. Вектор с 0 элементами - пустой.

Изменение размера с n до m:
-Элементы с 0 до m-1 сохраняют значения
-Увеличение с n до p: Элементы с n до p-1 могут быть неопределены или инициализированы
 значениями по умолчани. 0 - n-1 сохраняют значения.


Логическое описание:

typedef struct {
    T *data;
    int size;
} Vector;

void create(Vector *v, int size) {
    v->size = size;
    v->data = malloc(sizeof(T) * size);
}

int size(Vector *v)
{
    return v->size;
}

bool load(Vecor *v, int i)
{
    if (i >= 0 && i < v->size)
        return v->data[i];
}

bool save(Vector *v, int i, T t)
{
    if (i >= 0 && i < v->size)
        v->data[i] = t;
        return true;
    return false;
}


void resize(Vector *v, int size)
{
    v->size = size;
    v = realloc(sizeof(T) * v->size);
}


bool equal(Vecor *v1, Vector *v2)
{
    if (v1->size != v2->size)
    {
        return false;
    }

    for (int i = 0; i < v1->size; i++) {
        if (v1->data[i] != v2->data[i]) {
            return false;
        }
    }
    return true;
}


3.2 Алгоритм Рутисхаузера (Предполагает скообочную структру выражения)

Номер уровня:
1) Открывающая скобка или переменная - уроень + 1
2) Закр. скобка или операцтор - уровень - 1

Этапы:
1) Расставить уровни
2) Отыскать элемент с макс. уровнем
3) Выделить тройку: 2 операнда с макс. уровнем и операция между ними
4) Заменить тройку переменной
5) Удалить тройку, поместить переменную (Уровень - 1)
6) Выполн 2-5, пока не останется 1 переменная


# 4 Билет


Стек. Функциональная спецификация

Стек - структорая с последовательным доступом. Неразрушающей записью и разрушющем чтением.

Операции:
1) пополнение
2) Проверка на пустоту
3) Просмотр верхнего элемента
4) Уничтожение последнего элемента

используются для:
1) Изучения физ. процессов
2) Синтаксического анализа. 
3) Выполения рекурсивных процедур.

Функциональная спецификация:
.) Создать: Пусто -> ST
.) Пусто: ST -> BOOLEAN
.) ДЛИНА: ST -> N
.) в_СТЕК: ST*T -> ST
.) из_СТЕК: ST -> T
.) ВЕРХ: ST -> T
.) Уничтожить: ST -> ПУСТО

Св-ва:
1) Пусто(Создать) = true
2) Пусто(в_стек(S, T)) = false
3) верх(в_стек(s, T)) = T


4.2 Дерево поиска

Двоичные деревья часто используются для представления м-ва данных, 
элементы которых должны быть найдены по некоторому ключу. Если дерево
организовано так, что для любой вершины t справедливо, что любой ключ
левого поддерева меньше ключа t, а любой ключ правого поддерева больше 
ключа t, то такое двоичное дерево называется деревом поиска.

По построению: при поиске ключа в одном из поддеревьев мы автоматически
отбрасываем все ключи друго поддерева.

tree locate(int x, tree t)
{
    while (t && t->key != x){
        if (t->key < x)
            t = t->r;
        else
            t = t->l;
    }
    return t;
}

Поиск по дереву с влюченими.

Требуется определить частоту вхождения каждого из слов в последовательность, поступающих
из входного файла. 
Надо найти слово в дереве и добавить 1 к находящемуся в составе узла счетчику, либо в случае 
неуспеха поиска, добавить слово в дерево и в соотв. поле счетчкика установить единичное значение.

struct word;
typedef struct word* wp;

struct word
{
    int key;
    int count;
    wp l, r;
}


void search(int key, wp p)
{
    if (!p)
    {
        p = malloc(sizeof(wp));
        p->key = x;
        p->count = 1;
        p->l = p->r = NULL;
    }
    else
    {
        if (x < p->key)
        {
            search(key, p->l);
        }
        else
        {
            search(key, p->r);
        }
    }
}


# 5 Билет

5.1 Итераторы. 

Для реализациии сложных динамическийх структур данных цепного / сплошного 
характера принято использовать итераторы.

Для удобства реализациии списка определим объекты, обладающие функциями переходы
от данного элмента списка к соседним. Зададим для них отношение равенства. Два
итератора равны тогда и только тогда, когда они указывают на один и тот же 
элемент списка. Также предоставим возможность чтения и записи элемента списка посредством 
итераторов.

struct Item {
    struct Item *prev;
    struct Item *next;
    T data;
}


typedef struct { Item *node } Iterator;


bool equal(Iterator *lhs, Iterator *rhs)
{
    return lhs->node == rhs->node;
}

Iterator *next(Iterator *i)
{
    i->node = i->node->next;
    return i;
}


Iterator *prev(Iterator *i)
{
    i->node = i->node->;
    return i;
}


T fetch(Iterator *i)
{
    return t->node->data;
}

void stor(Iterator *i, T value)
{
    i->node->data = value;
}


# 6 Билет


6.1 Двоичное дерево. Физическое представление. Прошивка.

Жесткое размещение:

Корень дерева расположим в первом элементе массива
Во втором и третьем элементе расположим корни правого и левого поддерева

1) Сыновья дерева i находятся на на 2*i и 2*i + 1 позициях
2) j элемент уровня i находится на  2^(i-1) + j - 1 позиции


Способ экономичен по памяти. 
Неудобства: высокая цена вставки и удаления элементов.
            Перерасход памяти на пустые элементы.


Решение: ссылочное представление. Для каждой вершины храним ссылку
на левое и правое поддерево. 


Прошивка.

В прошитых бинарных деревьев вместо пустых указателей хранятся специальные
нити-связи и каждый указатель дополняется однобитовым признаком ltag || rtag.
Признак сообщает содержится ли в указателе ссылка на поддерево или в нем содержится 
нить-связь. 

Связь l: узел предшественник в центрированном (inorder) порядке обхода
Связь r: узел преемник в обратном порядке обхода

Право(лево)-прошитые деревья: содержится только ltag или rtag



# 7 Билет


Динамические и статические данные. 

Св-ва объекта, которые не изменяются при любом исполнении программы называются
статическими. (Можно определить по тексту программы, без исполнения)

Св-ва объекта, изменяемые при исполнениии - динамические.
Пример: значение переменной


Если память выделяется в процессе трансляции и ее объем не меняется - статичский объект.
Если память выделяется в во время выполнения и ее может меняется - динамический объект.


Адресный тип. Полиморфизм при помощи АТ
АТ имеет м-во значений - диапазон допустимых адресов ЭВМ. Объекты адресного типа совместимы
по присваиванию и сравнению с любыми ссылочными переменными. Адресный тип совместим с целым. 
Для него действуют арифметическеие операции. Полностью устраняет контроль типов, поэтому его
следует использовать только для низкоуровневых родовых модулей.


Для реализациии полиморфных функий, зависящих от типа в с++ используется понятие шаблона 
функции. Шаблон - подпрограмма, предъявляющая определенные требования для параметров функции

Пример:

template <class T>
void inlide_swap(T& lhs, T& rhs)
{
    T t = lhs;
    lhs = rhs;
    rhs = t;
}

(Требование: наличие оператора присваивания)


# Билет 8

Линейный список. Функциональная спецификация

Линейный список - обобщение последовательных структры с ограниченным
доступаом: файлов, стеков, очередей. Он позволяет представить посдедовательность
элементов так, что каждый элемент был бы досупен вне зависимости от положения

Линейный спискк представлен в ЭВМ в виде конечного упорядоченного
динамического множества (мультимножетсва, так как элементы могут повторятся).
элементов типа Т. Элементы линейно упорядочены, однако сравнеение происходит не по индексу, 
а с соседними элементами. 


Пример: описание переменных int x, y, z;

-Для поиска необходимо пройтись по списку с его начала (Линейное время)
-Для удаления необходимо найти элемент за линейное время и удалить за O(1)
-Для вставки необходимо указать значение перед(после) которого необходимо произвести вставку.

Функциональная спецификация:

1) СОЗДАТЬ EMPTY -> LT
1) ПУСТО LT -> EMPTY
2) ДЛИНА LT -> N
3) ПЕРВЫЙ LT -> T
4) ПОСЛЕДНИЙ LT -> T
5) СЛЕД LT*T -> T
6) ПРЕД LT*T -> T
7) УДАЛИТЬ LT*T -> LT
8) ВСТАВКА LT*T -> LT
9) УНИЧТОЖИТЬ LT*T -> EMPTY

св-ва:
пред(след(ЛТ, Т)) = Т
след(пред(ЛТ, Т)) = Т

Сортировка Хоара:

Выберем наугад элемент X (зерно) и будем просматривать массив слева пока не обнаружим
ai > x, затем проходя тот же массив справа от X будем искать элемент aj < x. Поменяем эти
два элемента, чтобы уничтожить инверсию. Продолжим процесс просмотра и перестаноки, пока оба
проходы не встретятся где-то в середнине массива.


void quick_sort(int *a, int l, int r)
{
    int i, j, tmp;
    x = a[(l + r) / 2]
    i = l;
    j = r;

    do {
        while (a[i] < x) {
            i++;
        }
        while (a[j] > x) {
            j--;
        }

        if (i < j) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
            i++;
            j--;
        }
    } while (i < j);

    if (l < j) quick_sort(a, l, j);
    if (i < r) quick_sort(a, i, r)
;
}



# Билет 9

Представление и обработка деревьев общего вида.

Дерево - структура данных, наиболее приспособленная для решения
задач ИИ и статического анализа.

Рекурсивное определение.

Пусть Т - тип данных. Дереевом типа Т называетяся структура данных, которая 
образова элементов типа Т (корнем) и конечным (возможно пустым) множеством
деревьев типа Т (Поддеревьев)

Представление
1) Стандартное
2) Вложенные диаграммы Эйлера-Венна
3) Иерархическая скобочная структура
4) Матрица смежности 

для описания связей в дереве используется древо-генеалогическая
терминология (отец, сын, потомок...)


Двоичная интерпретация дерева общего вида.

для преобразования дерева общего вида в бинарное Деревоу у
каждого узла соединить его сыновей (выстроив тем самым очередь 
из сыновей), а так убрать все связи узла с 
сыновьями, кроме единственного.


Общий вид алогоритма
1) Корень B - корень Физическое
2) Левое поддерво - результат того же преобразования для первого поддерева А
2) Правое поддерво - результат того же преобразования для второго поддерева А


# Билет 10

10.1 Алгоритм Дейкстра

Алгоритм представляет собой способ разбора мат. выражений, представленных
в инфиксной форме. Результат применения алгоритма - обратная польская запись.


Прочитать лексему
Если лексема число - добавить ее в выходную очередь

Если функция - поместить в стек
Если запятая (разделитель аргументов в функции):
    Пока на вершине не открыв скобка - перемещать операторы из стека в выходную очередь

Если лексема - оператор1
    Пока присутсвует оператор2 на стеке:
        Перекладывать оперетор2 в выходную очередь
    Положить оператор1 в стек

Если лексема закрывающая скобка:
    Выталкиваем из стека в выходную очередь пока не откр скобка

Если на входе не осталось лексем:
    Выталкиваем из стека операторы в выходную очередь